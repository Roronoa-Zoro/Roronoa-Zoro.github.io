---
layout: post
title:  "数据库缓存一致性"
date:   2016-10-28 +0800
categories: concurrent
tags: concurrent
author: Jimmy Lee
---

* content
{:toc}

### 前言
尝试着总结一下数据库和缓存数据一致性的问题  


### 写方案一
1. 更新数据库
2. 实效缓存


##### 存在的问题一,并发读写的问题  
![](/images/cache-solution-1.png)


会造成旧值存在缓存中,这种操作的概率应该很低，毕竟读比写快很多，t4应该很难发生在t3之前


##### 存在的问题二, 更新不同时成功  
![](/images/cache-solution-1.1.png)  

由于操作数据库和缓存不是原子操作，那么可能会造成缓存中的值还存在，就是以后读到旧值


### 写方案二
1. 先删除缓存
2. 在更新数据库


##### 存在的问题, 并发读写时发生,依然是把旧值放入了缓存
![](/images/cache-solution-2.png) 


### 方案三:这种方式应该没人用
1. 先写数据库
2. 再更新缓存


### 我们的方式:
1. 首先缓存得加过期时间。时间越短，命中数据库的次数会越多，时间长，那么出现不一致时的影响时间也会更久。
![](/images/cache-solution-3.png) 


##### 存在的问题：
1. 如果在t2时刻的并发较大,会全打到数据库
2. 增加的逻辑的复杂性


#### 权衡：
我们的账户余额，发生过并发读写造成了新的余额并没有写到缓存中(缓存的值比数据库的值大很多，而且缓存时间也设的比较长).  
然后后续没有写操作,就是读这个余额进行业务操作（撮合放款）,到最后实际放款,用户就是钱不够,业务失败.  
结合自身的业务情况,我们觉得缓存出错不能接受,而且也不会发生说t2时刻有成千上万的并发发生,所以我们用了这种方案。  

#### 总结：
1. 如果不考虑网络的不稳定性，方案一还是不错的
2. 关于我们的方案，不一定多好，我也相信大家也有很多自己的变体，欢迎大家多提供好的方式。

